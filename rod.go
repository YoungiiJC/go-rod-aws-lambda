package main

import (
	"time"

	"github.com/go-rod/rod"
	"github.com/go-rod/rod/lib/launcher"
	"github.com/go-rod/rod/lib/proto"
	"github.com/ssoroka/slice"
)

func launchInLambda() *launcher.Launcher {
	return launcher.New().
		// where lambda runtime stores chromium
		Bin("/opt/chromium").

		// recommended flags to run in serverless environments
		// see https://github.com/alixaxel/chrome-aws-lambda/blob/master/source/index.ts
		Set("allow-running-insecure-content").
		Set("autoplay-policy", "user-gesture-required").
		Set("disable-component-update").
		Set("disable-domain-reliability").
		Set("disable-features", "AudioServiceOutOfProcess", "IsolateOrigins", "site-per-process").
		Set("disable-print-preview").
		Set("disable-setuid-sandbox").
		Set("disable-site-isolation-trials").
		Set("disable-speech-api").
		Set("disable-web-security").
		Set("disk-cache-size", "33554432").
		Set("enable-features", "SharedArrayBuffer").
		Set("hide-scrollbars").
		Set("ignore-gpu-blocklist").
		Set("in-process-gpu").
		Set("mute-audio").
		Set("no-default-browser-check").
		Set("no-pings").
		Set("no-sandbox").
		Set("no-zygote").
		Set("single-process").
		Set("use-gl", "swiftshader").
		Set("window-size", "1920", "1080")
}

func getPageHTML(url string) (string, error) {
	// we want Rod to timeout before the lambda function
	// so we can ensure that the browser is properly killed
	// average website load time is ~10 seconds
	// let's be a little liberal here :p
	const timeout = 15 * time.Second // lambda fn timeout=20

	var html string

	err := rod.Try(func() {
		// instantiate the chromium launcher
		launcher := launchInLambda()

		// lambda warm starts reuse environments:
		//
		// we must delete data generated by the browser,
		// otherwise repeated calls to this fn will eat up storage
		// and the lambda will fail
		defer launcher.Cleanup()
		//
		// likewise, browser.close() will leave a zombie process
		// so we must kill the chromium processes completely
		// otherwise memory consumption will be much higher
		defer launcher.Kill()

		u := launcher.MustLaunch()

		// create a browser instance
		var browser *rod.Browser
		browser = rod.New().ControlURL(u).MustConnect()

		// open a page
		page := browser.MustPage()

		// Block loading any resources we don't need in headless
		// https://go-rod.github.io/#/network?id=blocking-certain-resources-from-loading
		router := page.HijackRequests()

		resources := []proto.NetworkResourceType{
			proto.NetworkResourceTypeFont,
			proto.NetworkResourceTypeImage,
			proto.NetworkResourceTypeMedia,
			proto.NetworkResourceTypeStylesheet,
		}

		router.MustAdd("*", func(ctx *rod.Hijack) {
			if slice.Contains(resources, ctx.Request.Type()) {
				ctx.Response.Fail(proto.NetworkErrorReasonBlockedByClient)
				return
			}

			ctx.ContinueRequest(&proto.FetchContinueRequest{})
		})

		go router.Run()

		page.
			Timeout(timeout).
			MustNavigate(url).
			MustWaitLoad().
			MustElement("body")

		// wait until request events are done
		// otherwise, we might not get all the page's html
		// that's client-side rendered
		wait := page.MustWaitRequestIdle()
		wait()

		html = page.MustElement("html").MustHTML()
	})

	if err != nil {
		return "", err
	}

	return html, nil
}
